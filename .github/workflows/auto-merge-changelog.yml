name: ðŸ¤– Auto-merge changelog-only PRs

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, ready_for_review]
    branches: [ "main" ]

permissions:
  contents: write
  pull-requests: write
  statuses: read
  checks: read

concurrency:
  group: auto-merge-changelog-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

jobs:
  guard-and-merge:
    runs-on: ubuntu-latest
    timeout-minutes: 6
    steps:
      - name: Checkout (tooling only)
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v4.2.2

      - name: Evaluate PR (bot, branch, files, checks)
        id: eval
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7.1.0
        with:
          result-encoding: string
          script: |
            const pr = context.payload.pull_request;
            if (!pr) return 'skip: no pr in payload';

            const isBot = (pr.user?.login || '').toLowerCase().includes('github-actions');
            const isChangelogBranch = /^docs\/changelog-/.test(pr.head.ref);
            if (!isBot || !isChangelogBranch) return 'skip: not bot or not docs/changelog-*';

            if (pr.base.ref !== 'main') return 'skip: not targeting main';
            if (pr.draft) return 'skip: draft';

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              per_page: 100
            });
            const filenames = files.map(f => f.filename);
            const onlyChangelog = filenames.length === 1 && filenames[0] === 'CHANGELOG.md';
            if (!onlyChangelog) return `skip: changed files = ${filenames.join(', ')}`;

            const { data: status } = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });
            const states = status.statuses?.map(s => s.state) || [];
            const anyFail = states.includes('failure') || states.includes('error');
            if (status.state !== 'success' || anyFail) {
              return `wait: combined status = ${status.state} (${states.join(',')})`;
            }

            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });
            const failing = (checks.check_runs || []).filter(c => ['failure','timed_out','cancelled','action_required','stale','skipped'].includes((c.conclusion||'').toLowerCase()));
            if (failing.length) {
              return `wait: failing checks = ${failing.map(c => c.name + ':' + c.conclusion).join(', ')}`;
            }

            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['changelog-only']
              });
            } catch {}

            return 'merge';

      - name: Exit early (not eligible)
        if: startsWith(steps.eval.outputs.result, 'skip:')
        run: |
          echo "${{ steps.eval.outputs.result }}"
          exit 0

      - name: Exit early (waiting for checks)
        if: startsWith(steps.eval.outputs.result, 'wait:')
        run: |
          echo "${{ steps.eval.outputs.result }}"
          exit 0

      - name: Merge PR (squash)
        if: steps.eval.outputs.result == 'merge'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7.1.0
        with:
          script: |
            const pr = context.payload.pull_request;
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              merge_method: 'squash'
            });
            try {
              if (pr.head.repo?.full_name === context.repo.owner + '/' + context.repo.repo) {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'heads/' + pr.head.ref
                });
              }
            } catch (e) {
              core.warning('Branch cleanup skipped: ' + (e?.message || e));
            }
