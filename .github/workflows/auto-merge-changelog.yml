name: ðŸ¤– Auto-merge changelog-only PRs

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled, ready_for_review]
    branches: [ "main" ]

permissions:
  contents: write
  pull-requests: write
  statuses: read
  checks: read

concurrency:
  group: auto-merge-changelog-${{ github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

env:
  MACHINE_USER: ai-qc-bot
  REQUIRE_MACHINE_USER: true

jobs:
  guard-and-merge:
    runs-on: ubuntu-latest
    timeout-minutes: 6
    steps:
      - name: Checkout (tooling only)
        uses: actions/checkout@08c6903cd8c0fde910a37f88322edcfb5dd907a8 # v4.2.2

      - name: Evaluate PR (bot, branch, files, checks)
        id: eval
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7.1.0
        with:
          result-encoding: string
          script: |
            const pr = context.payload.pull_request;
            if (!pr) return 'skip: no pr in payload';

            if (pr.head.repo?.full_name !== `${context.repo.owner}/${context.repo.repo}`) {
              return 'skip: fork PR not eligible';
            }

            const isBot = (pr.user?.type === 'Bot') || (pr.user?.login || '').toLowerCase().includes('github-actions');
            const isChangelogBranch = /^docs\/changelog-/.test(pr.head.ref);
            if (!isBot || !isChangelogBranch) return 'skip: not bot or not docs/changelog-*';

            if (pr.base.ref !== 'main') return 'skip: not targeting main';
            if (pr.draft) return 'skip: draft';

            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              per_page: 100
            });
            const filenames = files.map(f => f.filename);
            const onlyChangelog = filenames.length === 1 && filenames[0] === 'CHANGELOG.md';
            if (!onlyChangelog) return `skip: changed files = ${filenames.join(', ')}`;

            const { data: status } = await github.rest.repos.getCombinedStatusForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });
            const states = status.statuses?.map(s => s.state) || [];
            if (status.state !== 'success' || states.includes('failure') || states.includes('error')) {
              return `wait: combined status = ${status.state} (${states.join(',')})`;
            }

            const { data: checks } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha
            });
            const failing = (checks.check_runs || []).filter(c => ['failure','timed_out','cancelled','action_required','stale'].includes((c.conclusion||'').toLowerCase()));
            if (failing.length) {
              return `wait: failing checks = ${failing.map(c => c.name + ':' + c.conclusion).join(', ')}`;
            }

            try {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['changelog-only','ai-qc-approved']
              });
            } catch {}

            return 'merge';

      - name: Exit early (not eligible)
        if: startsWith(steps.eval.outputs.result, 'skip:')
        run: |
          echo "${{ steps.eval.outputs.result }}"
          exit 0

      - name: Exit early (waiting for checks)
        if: startsWith(steps.eval.outputs.result, 'wait:')
        run: |
          echo "${{ steps.eval.outputs.result }}"
          exit 0

      - name: Check approvals & provenance
        id: approvals
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7.1.0
        with:
          result-encoding: string
          script: |
            const pr = context.payload.pull_request;
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              per_page: 100
            });
            const approvers = reviews.filter(r => r.state === 'APPROVED').map(r => (r.user?.login || '').toLowerCase());
            const hasAnyApproval = approvers.length > 0;
            const REQUIRE_MACHINE_USER = (process.env.REQUIRE_MACHINE_USER || 'false').toLowerCase() === 'true';
            const machineUser = (process.env.MACHINE_USER || '').toLowerCase();
            const hasMachineApproval = machineUser ? approvers.includes(machineUser) : false;
            if (REQUIRE_MACHINE_USER && !hasMachineApproval) return 'need-bot-approval';
            if (hasAnyApproval) return 'ok';
            return 'needs-approval';

      - name: Auto-approve (AI QC bot)
        if: steps.approvals.outputs.result == 'needs-approval'
        env:
          GITHUB_TOKEN: ${{ secrets.AI_QC_BOT_TOKEN != '' && secrets.AI_QC_BOT_TOKEN || secrets.GITHUB_TOKEN }}
        uses: hmarr/auto-approve-action@b40c1bfa9d20b6c60df0d09422da1b93a6a30757 # v3.2.1

      - name: Enforce machine-user provenance
        if: steps.approvals.outputs.result == 'need-bot-approval'
        run: |
          echo "::error::Machine-user approval required but not present. Configure MACHINE_USER/REQUIRE_MACHINE_USER or approve manually."
          exit 1

      - name: Merge PR (squash)
        if: steps.eval.outputs.result == 'merge'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7.1.0
        with:
          script: |
            const pr = context.payload.pull_request;
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              merge_method: 'squash'
            });
            try {
              if (pr.head.repo?.full_name === context.repo.owner + '/' + context.repo.repo) {
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: 'heads/' + pr.head.ref
                });
              }
            } catch (e) {
              core.warning('Branch cleanup skipped: ' + (e?.message || e));
            }

      - name: Comment merge result
        if: steps.eval.outputs.result == 'merge'
        uses: actions/github-script@f28e40c7f34bde8b3046d885e986cb6290c5673b # v7.1.0
        with:
          script: |
            const pr = context.payload.pull_request;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: "âœ… Auto-merged by **AI QC Safety Protocol**: changelog-only PR with all checks green."
            });
